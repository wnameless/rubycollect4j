{
  "name": "rubycollect4j",
  "tagline": "Ruby Collections for Java",
  "body": "[![Maven Central](https://maven-badges.herokuapp.com/maven-central/net.sf.rubycollect4j/rubycollect4j/badge.svg)](https://maven-badges.herokuapp.com/maven-central/net.sf.rubycollect4j/rubycollect4j)\r\n\r\n\r\nrubycollect4j\r\n=============\r\nRuby Collections for Java.\r\n\r\nThe rubycollect4j implements all methods refer to Ruby Array, Hash, Set, Enumerable, Enumerator, Range and String.\r\nIt also implements parts of Ruby Dir, File and Date methods.\r\n\r\nFor further information, please visit http://ruby-doc.org website.\r\n\r\nFor more documentation, please read JavaDoc on http://rubycollect4j.sf.net website.\r\n\r\nInstallation with Maven:\r\n``` xml\r\n<dependency>\r\n  <groupId>net.sf.rubycollect4j</groupId>\r\n  <artifactId>rubycollect4j</artifactId>\r\n  <version>${latest.version}</version>\r\n</dependency>\r\n```\r\n\r\nJava 8 with rubycollect4j:\r\n```java\r\n// Sorts the characters by its frequency based on the word 'Mississippi' case-insensitively.\r\nRubyString word = rs(\"Mississippi\"); // Equivalent to new RubyString(\"Mississippi\")\r\n\r\nString result = word.map(String::toLowerCase).sortBy((c) -> {\r\n      return word.count(c);\r\n    }).uniq().join();\r\n\r\np(result);\r\n// Output: \"mpis\"\r\n```\r\n\r\nJava 6 with rubycollect4j:\r\n```java\r\n// Finds 2 words which get the least and the most unique letters in upper case.\r\nRubyArray<String> words =\r\n  RubyFile.foreach(\"/usr/share/dict/web2\") // Dictionary of Mac OS\r\n    .minmaxBy(new TransformBlock<String, Integer>() {\r\n      public Integer yield(String item) {\r\n        return new RubyString(item).toA().uniq().count();\r\n      }\r\n    }).map«É(\"toUpperCase\");\r\n\r\np(words);\r\n// Output: [A, BLEPHAROCONJUNCTIVITIS]\r\n```\r\n\r\nSince v1.9.0,<br/>\r\nRubyIterables & RubyStrings are added, they are simply utility classes just like java.util.Arrays.<br/>\r\nThey provide the Ruby style ways to manipulate any Iterable and String (or CharSequence).<br/>\r\nHighly recommended to use with the @ExtensionMethod of [Project Lombok](https://projectlombok.org/).\r\n```java\r\nIterable<Integer> ints = Arrays.asList(3, 6, 7, 2);\r\nint max = RubyIterables.max(ints);\r\nSystem.out.println(max);   // Output: 7\r\n\r\nString trStr = RubyStrings.tr(\"Mississippi\", \"i\", \"I\");\r\nSystem.out.println(trStr); // Output: MIssIssIppI\r\n```\r\n\r\nPlease add following lines before running examples:\r\n```java\r\nimport static net.sf.rubycollect4j.RubyCollections.*;\r\nimport static net.sf.rubycollect4j.RubyKernel.p;\r\n```\r\n\r\nDemo ra() & newRubyArray():\r\n```java\r\np( ra(1, 2, 3, 4) );                         // Output: [1, 2, 3, 4]\r\np( ra(ra(1, 2)) );                           // Output: [[1, 2]]\r\nList<Integer> list = new ArrayList<Integer>();\r\nlist.add(1);\r\np( ra(list) );                               // Output: [1]\r\nMap<Integer, String> map = new LinkedHashMap<Integer, String>();\r\nmap.put(1, \"a\");\r\nmap.put(2, \"b\");\r\n// Any Iterable or Iterator object can be converted into RubyArray.\r\np( ra(map.values) );                         // Output: [a, b]\r\n// RubyArray is Comparable if the elements are Comparable.\r\np( ra(ra(3, 4), ra(1, 2)).sort() );          // Output: [[1, 2], [3, 4]]\r\n// RubyArray is both a List and a Ruby.Enumerable.\r\np( ra(1, 2, 3) instanceof List );            // Output: true\r\np( ra(1, 2, 3) instanceof Ruby.Enumerable ); // Output: true\r\n```\r\n\r\n```java\r\n// By default, ra() is just a wrapper to an existed List.\r\n// You can make a defensive copy by following codes.\r\nList<Integer> list = new ArrayList<Integer>();\r\nlist.add(1);\r\nRubyArray<Integer> ra = RubyArray.copyOf(list);\r\n```\r\n\r\nDemo rh(), hp(), Hash() & newRubyHash():\r\n```java\r\np( rh(\"a\", 1, \"b\" ,2) );                        // Output: {a=1, b=2}\r\nMap<String, Long> map = new HashMap<String, Long>();\r\nmap.put(\"abc\", 123L);\r\n// Any Map can be converted into RubyHash.\r\np( hp(map) );                                   // Output: {abc=123}\r\n// hp() simply creates an Entry and the word 'hp' means hash pair\r\np( Hash(ra(hp(\"a\", 1), hp(\"b\" ,2))) );          // Output: {a=1, b=2}\r\np( Hash(rh(\"a\", 1, \"b\", 2).toA()) );            // Output: {a=1, b=2}\r\n// The Entry of RubyHash is Comparable if the type of the key elements is Comparable.\r\np( rh(4, 3, 2, 1).sort() );                     // Output: [2=1, 4=3]\r\n// RubyHash is both a Map and a Ruby.Enumerable.\r\np( rh(1, 2, 3, 4) instanceof Map );             // Output: true\r\np( rh(1, 2, 3, 4) instanceof Ruby.Enumerable ); // Output: true\r\n```\r\n\r\n```java\r\n// By default, rh() makes a copy of input Map.\r\n// You can only wrap a LinkedHashMap up by following codes, because the keys of RubyHash need to be ordered.\r\nLinkedHashMap<Integer, String> map = new LinkedHashMap<Integer, String>();\r\nmap.put(1, \"a\");\r\nRubyHash<Integer, String> rh = RubyHash.of(map);\r\n```\r\n\r\nDemo newRubySet():\r\n```java\r\np( newRubySet(1, 2, 3, 3) );                                // Output: [1, 2, 3]\r\nList<Integer> list = new ArrayList<Integer>();\r\nlist.add(1);\r\nlist.add(1);\r\n// Any Iterable object can be converted into RubySet\r\np( newRubySet(list) );                                      // Output: [1]\r\n// RubySet is Comparable if the elements are Comparable.\r\np( newRubySet(newRubySet(3, 4), newRubySet(1, 2)).sort() ); // Output: [[1, 2], [3, 4]]\r\n// RubySet is both a Set and a Ruby.Enumerable.\r\np( newRubySet(1, 2, 3, 3) instanceof Set );                 // Output: true\r\np( newRubySet(1, 2, 3, 3) instanceof Ruby.Enumerable );     // Output: true\r\n```\r\n\r\n```java\r\n// By default, newRubySet() makes a copy of input Set.\r\n// You can only wrap a LinkedHashSet up by following codes, because the elements of RubySet need to be ordered.\r\nLinkedHashSet<Integer> set = new LinkedHashSet<Integer>();\r\nset.add(1);\r\nRubySet<Integer> rubySet = RubySet.of(set);\r\n```\r\n\r\nDemo rs() & new RubyString():\r\n```java\r\n// RubyString can be created from any Object.\r\np( new RubyString(1000L).count(\"0\") );                  // Output: 3\r\n// RubyString is also a RubyEnumerable of each character(as String).\r\np( rs(\"abc\").map(\"codePointAt\", 0) );                   // Output: [97, 98, 99]\r\n// RubyString implements fluent interface.\r\n// After multiple actions, you can turn it to a Java String by calling toS().\r\np( rs(\"ABC\").chop().capitalize().concat(\"001\").toS() ); // Output: Ab001\r\n// RubyString is both a CharSequence and a Ruby.Enumerable.\r\np( rs(\"abc\") instanceof CharSequence );                 // Output: true\r\np( rs(\"abc\") instanceof Ruby.Enumerable );              // Output: true\r\n```\r\n\r\nDemo abstract RubyEnumerable class:\r\n```java\r\n// You can simply make your class inherit all the RubyEnumerable methods by extending it.\r\npublic class YourIterableClass<E> extends RubyEnumerable<E> {\r\n  private final Iterable<E> iter;\r\n  \r\n  public YourIterableClass(Iterable<E> iter) { this.iter = iter; }\r\n  \r\n  @Override\r\n  protected Iterable<E> getIterable() { return iter; }\r\n}\r\n\r\n// The class which extends RubyEnumerable becomes a Ruby.Enumerable.\r\np( new YourIterableClass(iter) instanceof Ruby.Enumerable ); // Output: true\r\n```\r\n\r\nDemo RubyEnumerator.of() & RubyEnumerator.copyOf():\r\n```java\r\nMap<String, Long> map = new LinkedHashMap<String, Long>() {{ put(\"a\", 1L); put(\"b\", 2L); put(\"c\", 3L); }};\r\n// Any Iterable object can be wrapped into RubyEnumerator.\r\nRubyEnumerator<Entry<String, Long>> re = RubyEnumerator.of(map.entrySet());\r\n// RubyEnumerator is much like RubyEnumerable, but it is both an Iterator and an Iterable.\r\np( re instanceof Ruby.Enumerator ); // Output: true\r\np( re instanceof Ruby.Enumerable ); // Output: true\r\np( re instanceof Iterator );        // Output: true\r\np( re instanceof Iterable );        // Output: true\r\n// It can 'peek' and 'rewind'.\r\np( re.peek() );                     // Output: a=1\r\np( re.next() );                     // Output: a=1\r\np( re.next() );                     // Output: b=2\r\np( re.peek() );                     // Output: c=3\r\nre.rewind();\r\np( re.next() );                     // Output: a=1\r\n```\r\n\r\n```java\r\n// By default, RubyEnumerator.of() is just a wrapper to an existed Iterable.\r\n// You can make a defensive copy by following codes.\r\nMap<String, Long> map = new LinkedHashMap<String, Long>() {{ put(\"a\", 1L); put(\"b\", 2L); put(\"c\", 3L); }};\r\nRubyEnumerator<Entry<String, Long>> re = RubyEnumerator.copyOf(map.entrySet());\r\n```\r\n\r\nDemo RubyLazyEnumerator.of() & RubyLazyEnumerator.copyOf():\r\n```java\r\nRubyLazyEnumerator rle = RubyLazyEnumerator.of(Arrays.asList(1, 2, 3, 4));\r\n// RubyLazyEnumerator is not a Ruby.Enumerable, but it is a Ruby.LazyEnumerator.\r\np( rle.drop(1) instanceof Ruby.LazyEnumerator );    // Output: true\r\np( rle instanceof Iterator );                       // Output: true\r\np( rle instanceof Iterable );                       // Output: true\r\np( rle.drop(1).toA() );                             // Output: [2, 3, 4]\r\n// A RubyLazyEnumerator can also be created by RubyArray#lazy.\r\np( ra(1, 2, 3, 4).lazy().cycle().drop(6).first() ); // Output: 3\r\n```\r\n\r\n```java\r\n// By default, RubyLazyEnumerator.of() is just a wrapper to an existed Iterable.\r\n// You can make a defensive copy by following codes.\r\nMap<String, Long> map = new LinkedHashMap<String, Long>() {{ put(\"a\", 1L); put(\"b\", 2L); put(\"c\", 3L); }};\r\nRubyLazyEnumerator<Entry<String, Long>> re = RubyLazyEnumerator.copyOf(map.entrySet());\r\n```\r\n\r\nDemo range():\r\n```java\r\np( range(1, 5).toA() );                                   // Output: [1, 2, 3, 4, 5]\r\np( range(\"Z\", \"AB\").toA() );                              // Output: [Z, AA, AB]\r\np( range(\"ZZ-999\", \"AAA-001\").toA() );                    // Output: [ZZ-999, AAA-000, AAA-001]\r\np( range(1.08, 1.1).toA() );                              // Output: [1.08, 1.09, 1.10]\r\np( range(\"1.08\", \"1.1\").toA() );                          // Output: [1.08, 1.09, 1.10]\r\np( range(date(2013, 06, 30), date(2013, 07, 01)).toA() ); // Output: [Sun Jun 30 00:00:00 CST 2013, Mon Jul 01 00:00:00 CST 2013]\r\n```\r\n\r\nDemo date():\r\n```java\r\np( date(2013, 7, 1).add(10).days() );          // Output: Thu Jul 11 00:00:00 CST 2013\r\np( date(2013, 7, 1, 21).minus(30).minutes() ); // Output: Mon Jul 01 20:30:00 CST 2013\r\np( date(2013, 7, 7, 16, 15, 14).endOfDay() );  // Output: Sun Jul 07 23:59:59 CST 2013\r\np( date(2013, 7, 11).beginningOfWeek() );      // Output: Sun Jul 07 00:00:00 CST 2013\r\np( RubyDate.today() );                         // Output: date of today\r\np( RubyDate.yesterday() );                     // Output: date of yesterday\r\nCalendar c = Calendar.getInstance();\r\nc.clear();\r\np( date(c.getTime()) );                        // Output: Thu Jan 01 00:00:00 CST 1970\r\np( date(2014, 5, 1).beginningOfQuarter() );    // Output: Tue Apr 01 00:00:00 CST 2014\r\n```\r\n\r\nDemo RubyObject.send():\r\n```java\r\nRubyHash<String, String> profile = rh(\"Name\", \"John Doe\", \"Gender\", \"Male\", \"Birthday\", \"2001/10/01\");\r\n// Assumes Object person has 3 setters: setName, setGender, setBirthday.\r\nprofile.each(new EntryBlock<String, String>() {\r\n  public void yield(String key, String value) {\r\n    RubyObject.send(person, \"set\" + key, value);\r\n  }\r\n});\r\n// As you can see, RubyObject.send() is a wrapper to Java Reflection.\r\n```\r\n\r\nDemo qw():\r\n```java\r\np( qw(\"a bc def\") ); // Output: [a, bc, def]\r\n```\r\n\r\nDemo qx():\r\n```java\r\np( qx(\"echo\", \"hello\") ); // Output: hello\r\n```\r\n\r\nDemo qr():\r\n```java\r\np( qr(\"^\\\\d+$\").matcher(\"123\").find() ); // Output: true\r\n```\r\n\r\nDemo RubyDir:\r\n```text\r\nfolder1\r\n       /folder1-1\r\n                 /file1-1-1\r\n                 /file1-1-2\r\n       /folder1-2\r\n                 /file1-2-1\r\n                 /file1-2-2\r\n                 /file1-2-3\r\n       /file1-1\r\n       /file1-2\r\n       /file1-3\r\n       /file1-4\r\n```\r\n\r\n```java\r\np( RubyDir.glob(\"folder1/*\").sort() );                 // Output: [file1-1, file1-2, file1-3, file1-4, folder1-1, folder1-2]\r\np( RubyDir.glob(GLOB_DIR + \"**/*1-*-1*\").sort() );     // Output: [folder1/folder1-1/file1-1-1, folder1/folder1-2/file1-2-1]\r\np( RubyDir.glob(GLOB_DIR + \"folder1/*[2,3]\").sort() ); // Output: [file1-2, file1-3, folder1-2]\r\n```\r\n\r\nDemo RubyFile:\r\n```java\r\nRubyFile rf = RubyFile.open(\"test.txt\", \"r+\");\r\nrf.puts(\"a\");\r\nrf.puts(\"bc\");\r\nrf.puts(\"def\");\r\nrf.close();\r\nrf = RubyFile.open(\"test.txt\", \"r\");\r\np( rf.eachLine().toA() );                         // Output: [a, bc, def]\r\nrf.close();\r\n// The method foreach() closes the stream automatically.\r\nRubyFile.foreach(\"test.txt\", new Block<String>() {\r\n  public void yield(String item) {\r\n    System.out.print( item );\r\n  }\r\n});                                               // Output: abcdef\r\np( RubyFile.join(\"/home/\", \"/ruby\", \"collect\") ); // Output: \"/home/ruby/collect\"\r\n```\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}